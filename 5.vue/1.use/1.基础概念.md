### 响应式，渐进式框架
### 库和框架的区别
    1. 以jq为例，库中一般有很多方法，一个完整的功能，通过这些功能实现我们自己的功能（主动 手动调用库中的方法）
    2. 框架一般是需要特定的代码，我们放到特定的位置，框架会帮助我们调用（被动）

### mvc和mvvm的区别
    1. 传统的mvc一般用于后端，model（数据库中的数据）view（前端页面）controller（后端的控制器），一般通过控制器操作数据返回给前端页面，单向的。 mvc框架（koa，express，egg都算是mvc的后端框架）
    2. model（js数据） viewmodel（视图模型，一般vue这种框架）view前端页面，原理就是我们吧js数据挂在到viewmodel上，页面就会自动更新，页面发生变化的话，数据也会更新，是一个双向的过程，mvvm一般是不需要手动操作dom，再vue中我们都是操作数据，数据变化页面就会自动更新

### vue官方打包的包很多
    1.带有esm的是es6的，common的是给node使用的，runtime的是不支持模板的，vue.js是支持模板的

### Vue
    1. 就是一个类，new Vue()创建一个实例返回的就是一个vm（viewModel）   
    2. 创建一个实例的时候如果我们写了template就不需要写render方法（会将template编译为render方法）-> 如果我们不写render也不写template那么会采用外部模板，就是html中写的页面结构，会将页面特定的数据替换掉。顺序先找render，没有找template，最后是页面结构，但是版本必须是runtime-with-compiler
    
### expression
    ```
    <div id="app">
        <!-- 当前的这个表达式最后会被编译成 _xxx(1+1) -->
        <!-- {{ 里面不能放js语法，因为最终会将返回值传递给函数 }} -->
        {{ 1 + 1 }}
        <!-- 函数返回的结果 -->
    </div>
    ```    

### vue中的数据监控的特点和缺陷
    ```
    let vm = new Vue({
        el: '#app',
        data() {
            // 1.响应式规则
            // 会去递归的循环每一个vue的属性(所以属性嵌套越深，越消耗性能。性能浪费，后面vue3中变成了proxy)，会为每一个属性增加getter和setter方法，当属性变化时会触发视图更新
            // 2.重写了数组的方法，当调用数组方法时也会触发更新，也会对数组的每一项就行监控
            return {
                // 对象只会监控默认自带的属性，再vm.msg.b新增的属性不会进行监控
                msg: { a: 1},
                // 如果是数据的长度或者索引发生变化，是不会触发视图更新的
                arr: [1,2,3]
            }
        }
    })

    // 这个2是不会被监控的，除非将data中初始化一个值，更改才会进行监控
    // vm.msg.b = 2
    
    //--vm.arr.length
    // 可以通过set方法对通过对数组的索引方式进行修改数组， 内部其实是采用的是splice的方法
    vm.$set(vm.arr, 0, 100)
    vm.$delete(vm.arr, 0)

    // 上面就是vue2中的缺陷，vue3中采用proxy进行解决了
    ```    

### proxy
    ```
    // proxy的原理
    let obj = {
        name: {
            name: 'shishaofei'
        },
        arr: ['吃', '喝', '玩']
    }

    // 缺点是兼容性差，
    // 可以代理13种方法 set get
    // defineProperty 只能对特定的属性进行拦截
    let handler = {
        get(target, key) {
            // console.log('依赖收集')
            // 对于对象的多层嵌套，我们要使用递归代理
            // 只有取到对应值的时候才会代理
            if(typeof target[key] === 'object' && target[key] !== null) {
                return new Proxy(target[key], handler)
            }
            // return target[key]  // 老的写法
            return Reflect.get(target, key)
        },
        set(target, key, value) {
            // 第一次key是索引，第二次是length
            console.log('触发更新', key)
            // 判断一下是新增操作还是修改操作
            let oldValue = target[key]
            console.log(oldValue, key, value)
            if(!oldValue) {
                console.log('新增属性')
            } else if(oldValue !== value) {
                console.log('修改属性')
            }
        
            // target[key] = value // 老的写法,设置值时老的写法会有一个问题，就是如果没有设置成功也不会报错，（对象不可配置的时候不能进行设置）
            // 新的写法如果没有设置成功会返回一个false
            return Reflect.set(target, key, value)
        }
    }

    let proxy = new Proxy(obj, handler)


    /**
    *  1.设置一个值并取一个值
    */
    // proxy.name = 123
    // console.log(proxy.name)

    /**
    * 2.object.assign只要是对象就会进行循环递归
    * proxy为懒代理，只有取到对应值的时候才会进行代理，如下我们进行取值,会发现只触发了一次更新
    * 对于对象的多层嵌套我们要进行修改
    */
    // proxy.name.name
    // proxy.name.name = 123

    /**
    * 3. 我们对数组进行代理
    * 我们发现对数组设置的时候，我们吧key打印出来，触发更新了两次
    * 第一次是3（即索引），第二次是length
    * 我们不能使其为两次更新，需要修改为那次是新增操作，哪次是修改操作
    */
    // proxy.arr.push(123)
    // proxy.arr[0] = 100
    // console.log(proxy.arr[0])

    /**
    * 4.如果对象上没有这个属性，也会触发set
    * 
    */
    proxy.xxx = 100
    ```

### vm.$mount
    ```
    let vm = new Vue({
        //el: '#app',
        template: '<div>{{msg}}</div>',
        data() {
            return {
                msg: 'hello world'
            }
        }
    })
    
    /** 
    * 挂在，如果没有参数 表示我要手动挂载，可以挂载再任何地方
    * vm.$el表示真是的dom
    * 当然也可以传递参数 vm.$mount('#app')
    */
    vm.$mount() 
    console.log(vm.$el) 
    document.body.appendChild(vm.$el)
    ```   

### vm.$options 用户传入组件实例的参数的所有选项，同时包括vue内置的属性方法   

### 指令：以v-开头得特殊得attribute，指令得值期待得是一个表达式，职责：当表达式得值发生改变得时候，将其连带的影响，响应的作用与dom上    封装得作用
    1. vue给我提供了一些无意义得标签template，可以将一些指令写在template上，渲染出来得dom就不会显示这个标签
    2. v-for对于循环得数组、数字等，我们在列表上给其加一个key，这个key必须是唯一得，所以一般我们不用index
    3. v-for与v-if不要一起使用，（在开发中会报错），因为优先级得问题，先执行v-for，然后再根据v-if进行判断，这样v-if会判断多次，影响性能不建议这么写，我们可以吧v-if写在外层，用一个template标签包裹
    4. 如果我们再template上进行循环列表，但是key不能卸载template标签上，要放在真实的元素上

### 指令的修饰符 @click.stop
    1. .stop组织冒泡
    2. self只作用于自身，不会影响父级
    3. .prevent组织默认行为
    4. .once事件只会触发一次
    5. .passive 不要把 .passive 和 .prevent 一起使用，因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，.passive 会告诉浏览器你不想阻止事件的默认行为  

### this指向
    1. 如果再data中写一些方法，再data中打印this会发现this指向的是window
    2. 如果放到methods中，this的指向就是这个vue实例  
    ```
    let vm = new Vue({
        el: '#app',
        data() {
            return {
                msg: 'hello world'
            }
        },
        methods: {
            // 如果调用方法时带上了()，需要手动传入事件源，名字是固定的$event
            fn(e) {
                console.log(e)
                // 这里的this绑定的是window，内部使用bind方法进行了实现，再进行bind是无效的
                console.log(this)
                // 如果相同就表示绑定到这个div上了，如果不同就表示使用了代理
                console.log(e.target, e.currentTarget)
            }
        }
    })
    ```

### v-model 
    1. 其实是一个语法糖,下面两种形式等价
    ```
    // 事件是绑定给元素的，并且是原生事件
    <input type="text" :value="msg" @input="(e) => msg = e.target.value">
    <input type="text" v-model="msg" >
    ```
    2. v-model也可以用在复选框，为什么呢
    3. v-model可以使用在哪些地方， input checkbox radio select textarea

### $watch
    ```
    vm.$watch('msg', function(newValue, oldValue) {
        console.log(newValue)
    })
    vm.msg = 10
    vm.msg = 100
    vm.msg = 1000

    // console.log(只会打印1000，因为只会更新一次)
    ```    
    1. 关于watch的写法很多
    ```
    let vm = new Vue({
        el: '#app',
        data() {
            return {
                msg: 1
            }
        },
        watch: {
            msg(newValue, oldValue) {
                console.log(newValue, oldValue)
            }
        }
    })
    ```
    2. 如果msg是一个对象，那么就不能按照上面的写法，因为要知道要不要监控msg里面的对象,使用deep解决深层问题，但是这样有一个缺点，如果是对象类型的就无法获取老值（oldValue）
    ```
    let vm = new Vue({
        el: '#app',
        data() {
            return {
                msg: {a: 1}
            }
        },
        watch: {
            msg: {
                handler(newValue, oldValue) {
                    console.log(newValue, oldValue)
                    // newValue.a = 100 oldValue.a = 100
                },
                // 如果当前的属性增加了deep，那么就会再对内部对象进行取值
                deep: true
            }
            
        }
    })
    setTimeout(() => {
        vm.msg.a = 100
    }, 500)
    ```
    3. immediate: true， 不会进行深层遍历，单层的时候表现一直，深层的时候oldValue为undefined，newValue为data中的初始值，深层的时候如果变化了不会执行
    ```
    let vm = new Vue({
        el: '#app',
        data() {
            return {
                msg: {a: 1}
            }
        },
        watch: {
            msg: [
                {
                    handler(newValue, oldValue) {
                        console.log(newValue, oldValue)
                    },
                    // 如果当前的属性增加了deep，那么就会再对内部对象进行取值
                    deep: true
                },
                {
                    handler(newValue, oldValue) {
                        console.log(newValue, oldValue)
                    },
                    immediate: true // 立即执行
                }
            ]
            
        }
    })
    setTimeout(() => {
        vm.msg.a = 100
    }, 500)
    ```
    3. 也可以是字符串，如果是字符串表示是methods中的方法,注意改的是msg，如果改msg.a不会执行fn函数
    ```
    let vm = new Vue({
        el: '#app',
        data() {
            return {
                msg: {a: 1}
            }
        },
        methods: {
            fn(newValue, oldValue) {
                console.log(newValue, oldValue)
                console.log('这是methods中的方法')
            }
        },
        watch: {
            msg: [
                {
                    handler(newValue, oldValue) {
                        console.log(newValue, oldValue)
                    },
                    // 如果当前的属性增加了deep，那么就会再对内部对象进行取值
                    deep: true
                },
                {
                    handler(newValue, oldValue) {
                        console.log(newValue, oldValue)
                    },
                    immediate: true // 立即执行
                },
                'fn'
            ]
            
        }
    })
    setTimeout(() => {
        vm.msg = 100
    }, 500)
    ```

### 使用v-model和computed属性实现多选框
    ```
    <div id="app">
        全选    <input type="checkbox" v-model="checkAll">
        <hr>
        <input type="checkbox" v-for="check of checks" v-model="check.check">
    </div>

    <script src="./node_modules/vue/dist/vue.js"></script>
    <script>
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    checks: [{check: true}, {check: true}, {check: true}]
                }
            },
            computed: {
                checkAll: {
                    get() {
                        return this.checks.every(item => item.check)
                    },
                    // 计算属性一般很少用set方法，因为一般都是取值。一般v-model会使用，
                    // 因为v-model是双向绑定，需要设置值
                    // 使用set的时候不要改自己，否则会死循环，都是改变其他数据来影响自己
                    set(newValue) {
                        return this.checks.map(item => item.check = newValue)
                    }
                }
            },
        })
    </script>
    ```    

### computed、methods和watch的区别
    1. computed、watch都是一个watcher
    2. 计算属性不会立即执行，只有取值的时候才会去执行，并且有缓存，如果依赖的数据不发生变化，那么就不会更新结果
    3. watch默认内部会先进行执行。会先算出一个老值来，如果数据变化就会执行回调函数
    4. 算一个结果我们一般不适用methods，因为不具备缓存，只要模板变化，函数就会重新执行,浪费性能

### 自定义指令
    ```
    <div id="app">
        <div v-click-outside="hide">
            <input type="text" @focus="show">
            <div v-show="isShow">
                显示面板 时间
            </div>
        </div>
        <input type="text" v-focus>
        <!-- 如果我们直接这样写，不生效，因为再页面初始化的时候确实聚焦了 -->
        <!-- 但是编译模板的时候重新插入了，所以显示不会聚焦 -->
        <input type="text" autofocus>
    </div>

    <script src="./node_modules/vue/dist/vue.js"></script>
    <script>
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    isShow: false
                }
            },
            directives: {
                // 指令有生命周期（钩子函数）
                // bind 指令第一次绑定到元素的时候执行，只会执行一次
                // inserted 插入
                // update 更新
                // unbind 
                // 默认写一个函数的话表示的是bind + update
                // clickOutside(el, bindings, vnode) {

                // }
                clickOutside: {
                    bind(el, bindings, vnode) {
                        let method = bindings.expression
                        el.handler = function(e) {
                            if(!el.contains(e.target)) {
                                vnode.context[method]()
                            }
                        }
                        document.addEventListener('click', el.handler)
                    },
                    unbind(el) {
                        document.removeEventListener('click', el.handler)
                    }
                },
                focus: {
                    inserted(el, bindings, vnode) {
                        el.focus()
                    }
                }
            },
            methods: {
                show() {
                    this.isShow = true
                },
                hide() {
                    this.isShow = false
                }
            }
            
        })
    </script>
    ```

### lifeCycle
    ```
    <script>
        // vue初始化的过程会让用户传入很多函数，在不用的时间点进行调用
        // 生命周期中的this只想都是当前实例
        // 生命周期都是同步执行

        // 这里可以写一些公共逻辑，混入到组件中，合并到相应的生命周期中，再组件对应的生命周期之前运行
        // 其实就是一个数组，依次执行['mixin created', 'created']
        // 缺点就是不知道来源， vue3.0中compositionApi进行解决这个问题
        Vue.mixin({
            beforeCreate() {
                console.log('初始化公共逻辑')
            },
            created() {
                console.log('公共的created')
            }
        })
        /**
         * ajax一般放在哪里？
         * 可以放在created中也可以放在mounted中，
         * 写前端一般习惯放在mounted中，其实是一样的，因为ajax是异步的，生命周期是同步的
         * 但是再服务端，我们一般放在created中，因为服务端没有mounted这个生命周期，没有dom
         * 父子组件渲染的过程
         * 父组件 beforeCreate created beforeMount render
         * 子组件 beforeCreate created beforeMount render mounted
         * 父组件 mounted
         */

        let vm = new Vue({
            el: '#app',
            /**
             * 这个时候没有进行数据观测（没有data），只是做了父子关系和一些内部事件，比如$on, $off
             * 这个地方可以混入公共逻辑，一般实在这个地方进行 Vue.mixin
             * 再这里通过mixin写公共方法和插件
             */
            beforeCreate() {
                console.log('before create')
               
            },
            // 初始化了一些数据，注入数据源（有data了已经）
            // 紧接着会将template模板编译到render函数中，没有dom，无法获取dom
            created() {
                console.log('created')
            },
            // 再第一次调用render之前调用
            beforeMount() {
                console.log('before mount')
            },
            render(h) {
                console.log('render')
                return h('div', this.msg)
            },
            // 创建真实dom，替换之前老的节点 vm.$el替换掉el， vm.$el即是真实dom， 渲染真实dom
            mounted() {
                console.log('mounted')
            },
            // 在这里可以做一些合并更新的操作
            beforeUpdate() {
                console.log('before update')
            },
            updated() {
                console.log('updated')
                // 不要再这里进行跟新数据了，会造成死循环
                // this.msg = Math.random()
            },
            // 可以做自定义事件的解绑，$off，做定时器的清理， 取消dom事件的绑定
            beforeDestroy() {
                console.log('before destroy')
            },
            destroyed() {
                console.log('destroyed')
            },
            data() {
                return {
                    msg: 'hello'
                }
            }
        })
        vm.msg = 100
        vm.$destroy()  // 手动销毁，只是移除监听，不会移除dom
    </script>
    ```    
### 动画
1. 数据的显示和隐藏，vue可以通过css来管理动画   
    - v-enter   // 进入的时候
    - v-enter-active    // 进入激活的时候，可以定义动画时长和效果
    - v-enter-to    // 进入最终的结果
    - v-leave       // 没有实际意义，为了堆成美感
    - v-leave-active    // 离开激活的时候，可以定义动画时长和效果
    - v-leave-to    // 离开最终的结果
2. 通过js来管理动画
3. 多元素的动画， transition-group

### 组件
- 组件中也有生命周期，组件分为两种 。 全局和局部
- 组件开发的好处
    1. 方便维护代码
    2. 可以实现组件级别的更新，给每一个组件添加一个watcher
    3. 抽离为单个组件，减少更新（更加独立）
- 组件其实就是一个对象
    1. 组建的实例化过程，会通过传入一个对象，创建一个vue实例 
- 为什么组件中的data必须是一个函数
    1. 为了防止组件之间的数据相互引用    
- 组件的使用可以在父级的模板中使用   
- 组件的构建的几种写法
    1. 传入一个对象，返回一个子的构造器，继承了Vue
    ```
    Vue.component('my-component', {
        data() {
            return {

            }
        }
    })
    ```
    2. Vue.extend()
    ```
    // 构造一个子类
    let Ctor = Vue.extend({
        data() {
            return {

            }
        }
    })
    Vue.component('my-component', Ctor)
    ```
    3. 可以直接创建一个实例，手动单独挂载
    ```
    let Ctor = Vue.extend({
        data() {
            return {

            }
        }
    })
    document.body.appendChild(new Ctor().$mount().$el)
    ```